---
layout: post
title: Java项目构建(0)
categories: []
tags: []
published: True

---
---
接触的Java项目越来越多，我发现很多Java程序猿的Java项目只能依赖一个特定的工具，或者Eclipse，或者Intellj。编译部署的方式也是落后到让人吃惊，人肉更改配置文件，用IED打包成war包，通过可视化工具拉到服务器，重启tomcat...

如果在整个项目周期里面，你既是产品，又是设计，兼职测试，还是唯一的程序猿的时候，你可能没有感觉这样有什么不妥。Java世界里面，最简单的是获取一个可运行的Jar文件，这其中其实需要编译源代码，运行测试，拷贝Class文件到目标目录，打包Class文件为Jar文件这几步。在没用构建工具之前，一般人都是通过点击IDE上面的几个按钮就实现了上面的工作。

但是随着项目越来越复杂，团队越来越多人，不但有了产品，设计，程序猿还从原来的一个人变成了多人。这时你需要解决代码集成，你开始用Git来做版本管理，这时候问题可能就越来越多。代码在我这里明明可以运行呀，为什么到了别人那里就不行了？妈蛋，又编译不通过了，哪个混蛋提交少了文件？版本发布时由一个人把所有代码checkout到自己的机器编译打包，结果到服务器又跑不了了...

其实上面那些问题统统属于人祸，都是人造成的。我们都知道人往往是不靠谱的，很容易犯错误，所有上面编译代码，拷贝代码，运行测试等等那些重复繁琐可自动化的事情都应该让机器去做，程序猿要关注的只是编写实现功能的代码。

作为Java程序猿，不可能不知道Spring，用Spring的程序猿大多数都知道Maven，用过Maven的程序猿都说好，因为它拯救了Java程序猿，依赖管理可以让Java程序猿从千千万万的Jar堆里面全身而退。当Ruby程序猿愉快地敲下gem install, .Net程序猿挥舞Nuget的时候，我们的Maven也帮我们把Jar包下好了。

你们以为Maven也就这么点作用吗？很多Java程序猿对Maven的理解真的停留在依赖管理，面试的时候问过很多Java程序猿对Maven的认识，他们中很多人只知道Maven是用来作包管理的，甚至连它是一个构建工具都不知道。

了解.net的环境区分，一定会感觉.net程序猿很幸福吧。在开发环境用一套配置环境，测试环境和生产环境又另外分别不同的一套配置环境，整齐有序层次清晰，妈妈再也不担心看到你在代码里面写那些奇怪的hack代码了。其实Maven也可以方便地做到环境区分。

平常的java开发过程中，我们会使用到很多配置文件，比如下面这样。

<img src="{{ site.url }}/assets/images/20151127/p1.png" />

这还是普通小项目的配置文件，其实真实开发过程中很多项目配置文件之繁琐简直叹为观止，令人发指。
当我们在开发环境，测试环境，生产环境中不断切换，重复修改这些繁琐的配置文件的时候，很多程序猿相信自己能像驾驭自己多个女朋友那样轻易驾驭这一千几百个配置选项，能在它们中自由穿梭，游刃有余。但据不完全统计，很多时候我们还是可以看到有些程序猿把自己辛辛苦苦写好的代码发布到测试或者正式环境后，发现代码并没有按照自己愿意跑起来，于是费尽脑筋满头大汗百思不得其解，最后在加班加点到夜深人静的时候终于顿悟，某个配置文件忘改了，此时心中1024头草泥马在奔腾。

有些聪明的程序猿为了方便快速更改不同的配置文件，他们的配置文件是这样的。

<img src="{{ site.url }}/assets/images/20151127/p6.png" />
其实解决这个问题最好的方法是在开发过程中维护好不同环境的配置文件，让熟悉相应配置的成员维护相应的配置文件。于是配置文件的目录结构应该变成下面这样。

<img src="{{ site.url }}/assets/images/20151127/p2.png" />

不熟悉Maven profile的人可能很费解，上面这样目录结构，程序在运行的时候该读哪个配置文件呢？
这时候Maven profile就能帮上忙了。

profile可以让我们定义一系列的配置信息，然后指定其激活条件。这样我们就可以定义多个profile，然后每个profile对应不同的激活条件和配置信息，从而达到不同环境使用不同配置信息的效果。

Maven给我们提供了多种不同的profile激活方式。比如我们可以使用-P参数显式的激活一个profile，也可以根据不同的环境来自动激活，比如根据操作系统的不同激活不同的profile，也可以根据jdk版本的不同激活不同的profile，等等。

Maven的profile可以定义在Maven的settings.xml中，实际应用中我们一般定义在项目的pom.xml中，例如下面这样。

<img src="{{ site.url }}/assets/images/20151127/p3.png" />

然后配置打包插件根据不同的环境变量打包。

<img src="{{ site.url }}/assets/images/20151127/p4.png" />

运行Maven打包命令，只要带上不同的profileId就能正确把不同环境的配置文件打包进去。例如运行 mvn -Pdev package，能看到Maven会自动把dev这个文件夹下面的配置文件打包进去。

<img src="{{ site.url }}/assets/images/20151127/p5.png" />

其实用好Maven profile，还能避免很多不必要的坑。有同事为了在某环境发布一个版本，直接在那个环境的服务器上面的git仓库改了配置，但他又感觉不好提交代码，怕其他同事pull了代码build不通过。等到有一天另外一个同事更改了相同的配置文件，想把代码部署到服务器的时候问题就来了，另外那个同事必须要commit服务器上面那些他不熟悉的更改才能把他的代码pull到服务器，只能找来原来的同事来看回之前的配置文件，一起慢慢merge。恩，这种问题听起来很stupid，但我确实遇到过几次。

平时开发过程中，我们尽量做到只维护一份代码，让团队里面的每个人都对整个项目都由整体的认识，每个人都能方便地开发编译部署，在不同的环境可以灵活的切换（当然，生产环境有些配置只能相应的人员知道）。

顺便提一下，Gradle和Maven同样是自动化构建工具，但按照目前的发展情况看，Gradle的风头已经盖过了Maven。Gradle给人感觉最大的变化是简洁，Gradle放弃了Maven的基于XML的繁琐配置，基于Groovy的紧凑脚本实在让人爱不释手，在表述意图方面也没有什么不清晰的地方。另外一方面是灵活，各种在Maven中难以下手的事情，在Gradle就是小菜一碟，比如修改现有的构建生命周期，几行配置就完成了，同样的事情，在Maven中你必须编写一个插件，那对于一个刚入门的用户来说，花上一两天也不一定能搞定。

扯远了，回到Maven profile吧。总之，用好Maven profile就可以节省80%的精力，提高90%的效率，关键是让你早点下班回家。

这是Java项目构建(0)，也许还有（1），（2），（3）...
当然，也许只是也许。






